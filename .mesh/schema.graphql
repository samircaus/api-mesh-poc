schema {
  query: Query
}

"Indicates exactly one field must be supplied and this field must not be `null`."
directive @oneOf on INPUT_OBJECT

type Query {
  """Returns a greeting message"""
  hello: String
  """Get a single user by ID"""
  user(
    """User ID"""
    id: String!
  ): User
  """Get all users"""
  users: [User]
  """Get all products"""
  products(
    """Filter by category"""
    category: String
  ): [Product]
  """Get product by ID"""
  getProductById(
    """Product ID"""
    id: String!
  ): Product
  """Get all categories"""
  categories: [Category]
  """Get category by ID"""
  getCategoryById(
    """Category ID"""
    id: String!
  ): Category
  """Get list of cities with filtering and pagination"""
  cityList(
    """Filter criteria"""
    filter: FilterInput
    """Pagination offset"""
    offset: Int
    """Pagination limit"""
    limit: Int
  ): CityResults
  """Get city by path"""
  cityByPath(
    """Content fragment path"""
    _path: String!
  ): CityItem
  """Get list of persons"""
  personList(
    """Filter criteria"""
    filter: FilterInput
  ): PersonResults
  """Get person by path"""
  personByPath(
    """Content fragment path"""
    _path: String!
  ): PersonItem
  """Get list of companies"""
  companyList(
    """Filter criteria"""
    filter: FilterInput
  ): CompanyResults
  """Get list of awards"""
  awardList(
    """Filter criteria"""
    filter: FilterInput
  ): AwardResults
  """Get list of adventures"""
  adventureList(
    """Filter criteria"""
    filter: FilterInput
  ): AdventureResults
  """Get adventure by path"""
  adventureByPath(
    """Content fragment path"""
    _path: String!
  ): AdventureItem
  """Get paginated adventures"""
  adventurePaginated(
    """Number of items"""
    first: Int
    """Cursor"""
    after: String
  ): AdventurePaginated
  continent(code: ID!): Continent
  continents(filter: ContinentFilterInput = {}): [Continent!]!
  countries(filter: CountryFilterInput = {}): [Country!]!
  country(code: ID!): Country
  language(code: ID!): Language
  languages(filter: LanguageFilterInput = {}): [Language!]!
}

"""A city content fragment"""
type City {
  """Repository path"""
  _path: String
  """City name"""
  name: String
  """Country"""
  country: String
  """Population"""
  population: Int
  """Categories"""
  categories: [String]
  """Tags"""
  _tags: [String]
}

"""City query results"""
type CityResults {
  """List of cities"""
  items: [City]
}

"""Single city result"""
type CityItem {
  """The city"""
  item: City
}

"""A person content fragment"""
type Person {
  """Repository path"""
  _path: String
  """Last name"""
  name: String
  """First name"""
  firstName: String
  """Awards received"""
  awards: [Award]
}

"""Person query results"""
type PersonResults {
  """List of persons"""
  items: [Person]
}

"""Single person result"""
type PersonItem {
  """The person"""
  item: Person
}

"""A company content fragment"""
type Company {
  """Repository path"""
  _path: String
  """Company name"""
  name: String
  """CEO"""
  ceo: Person
  """Employees"""
  employees: [Person]
}

"""Company query results"""
type CompanyResults {
  """List of companies"""
  items: [Company]
}

"""An award"""
type Award {
  """Award ID"""
  id: String
  """Award title"""
  title: String
  """Repository path"""
  _path: String
  """Metadata"""
  _metadata: Metadata
}

"""Award query results"""
type AwardResults {
  """List of awards"""
  items: [Award]
}

"""Metadata for content fragments"""
type Metadata {
  """String metadata"""
  stringMetadata: [MetadataItem]
}

"""A metadata key-value pair"""
type MetadataItem {
  """Metadata key"""
  name: String
  """Metadata value"""
  value: String
}

"""An adventure content fragment"""
type Adventure {
  """Repository path"""
  _path: String
  """Adventure title"""
  title: String
  """Description"""
  description: String
  """Type of adventure"""
  adventureType: String
  """Price"""
  price: Float
}

"""Adventure query results"""
type AdventureResults {
  """List of adventures"""
  items: [Adventure]
}

"""Single adventure result"""
type AdventureItem {
  """The adventure"""
  item: Adventure
}

"""Paginated adventure results"""
type AdventurePaginated {
  """Edges"""
  edges: [AdventureEdge]
  """Pagination info"""
  pageInfo: PageInfo
}

"""Adventure edge for pagination"""
type AdventureEdge {
  """Cursor"""
  cursor: String
  """Node"""
  node: Adventure
}

"""Pagination information"""
type PageInfo {
  """End cursor"""
  endCursor: String
  """Has next page"""
  hasNextPage: Boolean
}

"""A user object"""
type User {
  """User ID"""
  id: String
  """User name"""
  name: String
  """User email"""
  email: String
  """User role"""
  role: String
}

"""A product object matching OpenAPI schema with Mesh federation support"""
type Product {
  """Unique product identifier"""
  id: String
  """Product name"""
  name: String
  """Product description"""
  description: String
  """Category ID for federation/joins"""
  categoryId: String
  """Product category name (Electronics, Wearables, Accessories)"""
  category: String
  """Template text with {{placeholders}} for category data"""
  text: String
  """Product price"""
  price: Float
  """Currency code"""
  currency: String
  """Whether product is in stock"""
  inStock: Boolean
  """Available quantity"""
  quantity: Int
  """Product image URL"""
  imageUrl: String
  """Product rating (3.0-5.0)"""
  rating: Float
  """Number of reviews"""
  reviews: Int
  """Product specifications"""
  specifications: ProductSpecifications
  """Product tags"""
  tags: [String]
}

"""A category object for product categorization"""
type Category {
  """Unique category identifier"""
  id: String
  """Category name"""
  name: String
  """Category description"""
  description: String
  """URL-friendly slug"""
  slug: String
  """Category image URL"""
  imageUrl: String
  """Parent category ID for nested categories"""
  parentId: String
}

"""Product specifications object"""
type ProductSpecifications {
  """Product weight"""
  weight: String
  """Product dimensions"""
  dimensions: String
  """Product color"""
  color: String
  """Product brand"""
  brand: String
}

"""Filter operators for string and numeric comparisons"""
enum FilterOperator {
  """Equals comparison"""
  EQUALS
  """Not equals comparison"""
  EQUALS_NOT
  """Contains comparison"""
  CONTAINS
  """Does not contain comparison"""
  CONTAINS_NOT
  """Starts with comparison"""
  STARTS_WITH
  """Ends with comparison"""
  ENDS_WITH
  """Greater than comparison"""
  GREATER
  """Greater than or equal comparison"""
  GREATER_EQUAL
  """Lower than comparison"""
  LOWER
  """Lower than or equal comparison"""
  LOWER_EQUAL
  """At comparison"""
  AT
  """Not at comparison"""
  NOT_AT
}

"""Expression for a single filter condition"""
input FilterExpressionInput {
  """The value to compare against"""
  value: String!
  """The comparison operator"""
  _operator: FilterOperator
}

"""Filter input for string fields"""
input StringFilterInput {
  """List of filter expressions"""
  _expressions: [FilterExpressionInput!]
  """Logical operator to combine expressions (AND/OR)"""
  _logOp: String
}

"""Filter input for integer fields"""
input IntFilterInput {
  """List of filter expressions"""
  _expressions: [FilterExpressionInput!]
  """Logical operator to combine expressions (AND/OR)"""
  _logOp: String
}

"""Filter input with field-specific filters"""
input FilterInput {
  """Filter on name field"""
  name: StringFilterInput
  """Filter on firstName field"""
  firstName: StringFilterInput
  """Filter on title field"""
  title: StringFilterInput
  """Filter on description field"""
  description: StringFilterInput
  """Filter on country field"""
  country: StringFilterInput
  """Filter on adventure type"""
  adventureType: StringFilterInput
  """Filter on population"""
  population: IntFilterInput
  """Filter on price"""
  price: IntFilterInput
  """Filter on path"""
  _path: StringFilterInput
}

type Continent {
  code: ID!
  countries: [Country!]!
  name: String!
}

input ContinentFilterInput {
  code: StringQueryOperatorInput
}

type Country {
  awsRegion: String!
  capital: String
  code: ID!
  continent: Continent!
  currencies: [String!]!
  currency: String
  emoji: String!
  emojiU: String!
  languages: [Language!]!
  name(lang: String): String!
  native: String!
  phone: String!
  phones: [String!]!
  states: [State!]!
  subdivisions: [Subdivision!]!
  displayName: String
  fullDescription: String
  hasCapital: Boolean
  currencySign: String
  description: String
}

input CountryFilterInput {
  code: StringQueryOperatorInput
  continent: StringQueryOperatorInput
  currency: StringQueryOperatorInput
  name: StringQueryOperatorInput
}

type Language {
  code: ID!
  countries: [Country!]!
  name: String!
  native: String!
  rtl: Boolean!
}

input LanguageFilterInput {
  code: StringQueryOperatorInput
}

type State {
  code: String
  country: Country!
  name: String!
}

input StringQueryOperatorInput {
  eq: String
  in: [String!]
  ne: String
  nin: [String!]
  regex: String
}

type Subdivision {
  code: ID!
  emoji: String
  name: String!
}